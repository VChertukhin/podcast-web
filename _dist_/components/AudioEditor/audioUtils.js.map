{"version":3,"sources":["audioUtils.ts"],"names":["createAudioCtx","AudioCtxClass","window","AudioContext","webkitAudioContext","mozAudioContext","audioCtx","createAudioBufferFromFile","file","onLoad","reader","FileReader","readAsArrayBuffer","onload","e","res","target","result","decodeAudioData","audioBufferSlice","buffer","begin","end","audioContext","error","duration","channels","numberOfChannels","rate","sampleRate","RangeError","startOffset","endOffset","frameCount","newArrayBuffer","createBuffer","anotherArray","Float32Array","offset","channel","copyFromChannel","copyToChannel","console","createStoryForSlice","sllicedBuffer","leftBuff","rightBuff","leftPart","rigftPart","createAudioFromStory","currBuffer","storyPiece","restoredBuffer","ctx","concatAudioBuffers","buffers","output","map","length","reduce","a","b","getChannelData","set","layerAudioBuffers","i"],"mappings":"AAAA;AAEA,OAAO,MAAMA,cAAc,GAAG,MAAM;AACnC,QAAMC,aAAa,GAClBC,MAAM,CAACC,YAAP,IACAD,MAAM,CAACE,kBADP,IAEAF,MAAM,CAACG,eAHR;AAKA,QAAMC,QAAQ,GAAG,IAAIL,aAAJ,EAAjB;AACA,SAAOK,QAAP;AACA,CARM;AAUP,OAAO,MAAMC,yBAAyB,GAAG,CACxCC,IADwC,EAExCF,QAFwC,EAGxCG,MAHwC,KAI9B;AACV,QAAMC,MAAM,GAAG,IAAIC,UAAJ,EAAf;AACAD,EAAAA,MAAM,CAACE,iBAAP,CAAyBJ,IAAzB;;AACAE,EAAAA,MAAM,CAACG,MAAP,GAAiBC,CAAD,IAAO;AACtB,UAAMC,GAAG,GAAGD,CAAC,CAACE,MAAF,EAAUC,MAAtB;AACAX,IAAAA,QAAQ,CAACY,eAAT,CAAyBH,GAAzB,EAA8BN,MAA9B;AACA,GAHD;AAIA,CAXM;AAaP,OAAO,MAAMU,gBAAgB,GAAG,CAC/Bb,QAD+B,EAE/Bc,MAF+B,EAG/BC,KAH+B,EAI/BC,GAJ+B,KAKd;AACjB,QAAMC,YAAY,GAAGjB,QAArB;AAEA,MAAIkB,KAAK,GAAG,IAAZ;AAEA,QAAMC,QAAQ,GAAGL,MAAM,CAACK,QAAxB;AACA,QAAMC,QAAQ,GAAGN,MAAM,CAACO,gBAAxB;AACA,QAAMC,IAAI,GAAGR,MAAM,CAACS,UAApB;;AAEA,MAAIR,KAAK,GAAG,CAAZ,EAAe;AACdG,IAAAA,KAAK,GAAG,IAAIM,UAAJ,CAAe,mCAAf,CAAR;AACA;;AAED,MAAIR,GAAG,GAAGG,QAAV,EAAoB;AACnBD,IAAAA,KAAK,GAAG,IAAIM,UAAJ,CAAe,4CAA4CL,QAA3D,CAAR;AACA;;AAED,QAAMM,WAAW,GAAGH,IAAI,GAAGP,KAA3B;AACA,QAAMW,SAAS,GAAGJ,IAAI,GAAGN,GAAzB;AACA,QAAMW,UAAU,GAAGD,SAAS,GAAGD,WAA/B;AACA,MAAIG,cAAJ;;AAEA,MAAI;AACHA,IAAAA,cAAc,GAAGX,YAAY,CAACY,YAAb,CAA0BT,QAA1B,EAAoCM,SAAS,GAAGD,WAAhD,EAA6DH,IAA7D,CAAjB;AACA,UAAMQ,YAAY,GAAG,IAAIC,YAAJ,CAAiBJ,UAAjB,CAArB;AACA,UAAMK,MAAM,GAAG,CAAf;;AAEA,SAAK,IAAIC,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGb,QAAhC,EAA0Ca,OAAO,EAAjD,EAAqD;AACpDnB,MAAAA,MAAM,CAACoB,eAAP,CAAuBJ,YAAvB,EAAqCG,OAArC,EAA8CR,WAA9C;AACAG,MAAAA,cAAc,CAACO,aAAf,CAA6BL,YAA7B,EAA2CG,OAA3C,EAAoDD,MAApD;AACA;AACD,GATD,CASE,OAAOxB,CAAP,EAAU;AACXU,IAAAA,KAAK,GAAGV,CAAR;AACA4B,IAAAA,OAAO,CAAClB,KAAR,CAAcV,CAAd;AACA;;AAED,SAAOoB,cAAP;AACA,CA1CM;AAiDP,OAAO,MAAMS,mBAAmB,GAAG,CAClCrC,QADkC,EAElCc,MAFkC,EAGlCC,KAHkC,EAIlCC,GAJkC,KAKH;AAC/B,QAAMsB,aAAa,GAAGzB,gBAAgB,CAACb,QAAD,EAAWc,MAAX,EAAmBC,KAAnB,EAA0BC,GAA1B,CAAtC;AACA,QAAMuB,QAAQ,GAAG1B,gBAAgB,CAACb,QAAD,EAAWc,MAAX,EAAmB,CAAnB,EAAsBC,KAAtB,CAAjC;AACA,QAAMyB,SAAS,GAAG3B,gBAAgB,CAACb,QAAD,EAAWc,MAAX,EAAmBE,GAAnB,EAAwBF,MAAM,CAACK,QAA/B,CAAlC;AACA,SAAO,CACNmB,aADM,EAEN;AACCG,IAAAA,QAAQ,EAAEF,QADX;AAECG,IAAAA,SAAS,EAAEF;AAFZ,GAFM,CAAP;AAOA,CAhBM;AAkBP,OAAO,MAAMG,oBAAoB,GAAG,CAACC,UAAD,EAA0BC,UAA1B,KAAkE;AACrG,MAAIC,cAAJ;AACA,MAAIC,GAAG,GAAGrD,cAAc,EAAxB;;AACA,MAAGmD,UAAU,CAACJ,QAAd,EAAwB;AACvBK,IAAAA,cAAc,GAAGE,kBAAkB,CAACD,GAAD,EAAM,CAACF,UAAU,CAACJ,QAAZ,EAAsBG,UAAtB,CAAN,CAAnC;AACA;;AACD,MAAIC,UAAU,CAACH,SAAf,EAA0B;AACzBI,IAAAA,cAAc,GAAGE,kBAAkB,CAACD,GAAD,EAAM,CAACH,UAAD,EAAaC,UAAU,CAACH,SAAxB,CAAN,CAAnC;AACA;;AACD,SAAOI,cAAP;AACA,CAVM;AAYP,OAAO,MAAME,kBAAkB,GAAG,CAAChD,QAAD,EAAyBiD,OAAzB,KAAiE;AAClG,QAAM7B,QAAQ,GAAG6B,OAAO,CAAC,CAAD,CAAP,CAAW5B,gBAA5B;AACA,MAAI6B,MAAM,GAAGlD,QAAQ,CAAC6B,YAAT,CACZT,QADY,EAEZ6B,OAAO,CAACE,GAAR,CAAYrC,MAAM,IAAIA,MAAM,CAACsC,MAA7B,EAAqCC,MAArC,CAA4C,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAA1D,EAA6D,CAA7D,CAFY,EAGZN,OAAO,CAAC,CAAD,CAAP,CAAW1B,UAHC,CAAb;;AAMA,OAAK,IAAIU,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGb,QAAhC,EAA0Ca,OAAO,EAAjD,EAAqD;AACpD,QAAID,MAAM,GAAG,CAAb;AACAiB,IAAAA,OAAO,CAACE,GAAR,CAAYrC,MAAM,IAAI;AACrBoC,MAAAA,MAAM,CAACM,cAAP,CAAsBvB,OAAtB,EAA+BwB,GAA/B,CAAmC3C,MAAM,CAAC0C,cAAP,CAAsBvB,OAAtB,CAAnC,EAAmED,MAAnE;AACAA,MAAAA,MAAM,IAAIlB,MAAM,CAACsC,MAAjB;AACA,KAHD;AAIA;;AACD,SAAOF,MAAP;AACA,CAhBM;AAkBP,OAAO,MAAMQ,iBAAiB,GAAG,CAAC1D,QAAD,EAAyBiD,OAAzB,KAAiE;AACjG,QAAM7B,QAAQ,GAAG6B,OAAO,CAAC,CAAD,CAAP,CAAW5B,gBAA5B;AACA,MAAI6B,MAAM,GAAGlD,QAAQ,CAAC6B,YAAT,CACZT,QADY,EAEZ6B,OAAO,CAACE,GAAR,CAAYrC,MAAM,IAAIA,MAAM,CAACsC,MAA7B,EAAqCC,MAArC,CAA4C,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAA1D,EAA6D,CAA7D,CAFY,EAGZN,OAAO,CAAC,CAAD,CAAP,CAAW1B,UAHC,CAAb;;AAMA,OAAK,IAAIU,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGb,QAAhC,EAA0Ca,OAAO,EAAjD,EAAqD;AACpDgB,IAAAA,OAAO,CAACE,GAAR,CAAYrC,MAAM,IAAI;AACrB,WAAK,IAAI6C,CAAC,GAAG7C,MAAM,CAAC0C,cAAP,CAAsBvB,OAAtB,EAA+BmB,MAA/B,GAAwC,CAArD,EAAwDO,CAAC,IAAI,CAA7D,EAAgEA,CAAC,EAAjE,EAAqE;AACpET,QAAAA,MAAM,CAACM,cAAP,CAAsBvB,OAAtB,EAA+B0B,CAA/B,KAAqC7C,MAAM,CAAC0C,cAAP,CAAsBvB,OAAtB,EAA+B0B,CAA/B,CAArC;AACA;AACD,KAJD;AAKA;;AACD,SAAOT,MAAP;AACA,CAhBM","sourcesContent":["/* eslint-disable */\n\nexport const createAudioCtx = () => {\n\tconst AudioCtxClass = (\n\t\twindow.AudioContext ||\n\t\twindow.webkitAudioContext ||\n\t\twindow.mozAudioContext\n\t);\n\tconst audioCtx = new AudioCtxClass();\n\treturn audioCtx;\n}\n\nexport const createAudioBufferFromFile = (\n\tfile: File,\n\taudioCtx: AudioContext,\n\tonLoad: (buf: AudioBuffer) => void,\n): void => {\n\tconst reader = new FileReader();\n\treader.readAsArrayBuffer(file);\n\treader.onload = (e) => {\n\t\tconst res = e.target?.result as ArrayBuffer;\n\t\taudioCtx.decodeAudioData(res, onLoad);\n\t}\n}\n\nexport const audioBufferSlice = (\n\taudioCtx: AudioContext,\n\tbuffer: AudioBuffer,\n\tbegin: number,\n\tend: number,\n): AudioBuffer => {\n\tconst audioContext = audioCtx\n\n\tlet error = null;\n\n\tconst duration = buffer.duration;\n\tconst channels = buffer.numberOfChannels;\n\tconst rate = buffer.sampleRate;\n\n\tif (begin < 0) {\n\t\terror = new RangeError('begin time must be greater than 0');\n\t}\n\n\tif (end > duration) {\n\t\terror = new RangeError('end time must be less than or equal to ' + duration);\n\t}\n\n\tconst startOffset = rate * begin;\n\tconst endOffset = rate * end;\n\tconst frameCount = endOffset - startOffset;\n\tlet newArrayBuffer;\n\n\ttry {\n\t\tnewArrayBuffer = audioContext.createBuffer(channels, endOffset - startOffset, rate);\n\t\tconst anotherArray = new Float32Array(frameCount);\n\t\tconst offset = 0;\n\n\t\tfor (let channel = 0; channel < channels; channel++) {\n\t\t\tbuffer.copyFromChannel(anotherArray, channel, startOffset);\n\t\t\tnewArrayBuffer.copyToChannel(anotherArray, channel, offset);\n\t\t}\n\t} catch (e) {\n\t\terror = e;\n\t\tconsole.error(e);\n\t}\n\n\treturn newArrayBuffer as AudioBuffer;\n}\n\nexport type StoryPiece = {\n\tleftPart: AudioBuffer | null;\n\trigftPart: AudioBuffer | null;\n}\n\nexport const createStoryForSlice = (\n\taudioCtx: AudioContext,\n\tbuffer: AudioBuffer,\n\tbegin: number,\n\tend: number,\n): [AudioBuffer, StoryPiece] => {\n\tconst sllicedBuffer = audioBufferSlice(audioCtx, buffer, begin, end);\n\tconst leftBuff = audioBufferSlice(audioCtx, buffer, 0, begin);\n\tconst rightBuff = audioBufferSlice(audioCtx, buffer, end, buffer.duration);\n\treturn [\n\t\tsllicedBuffer,\n\t\t{\n\t\t\tleftPart: leftBuff,\n\t\t\trigftPart: rightBuff,\n\t\t}\n\t];\n}\n\nexport const createAudioFromStory = (currBuffer: AudioBuffer, storyPiece: StoryPiece): AudioBuffer => {\n\tlet restoredBuffer: AudioBuffer;\n\tlet ctx = createAudioCtx();\n\tif(storyPiece.leftPart) {\n\t\trestoredBuffer = concatAudioBuffers(ctx, [storyPiece.leftPart, currBuffer]);\n\t}\n\tif (storyPiece.rigftPart) {\n\t\trestoredBuffer = concatAudioBuffers(ctx, [currBuffer, storyPiece.rigftPart]);\n\t}\n\treturn restoredBuffer!;\n}\n\nexport const concatAudioBuffers = (audioCtx: AudioContext, buffers: AudioBuffer[]): AudioBuffer => {\n\tconst channels = buffers[0].numberOfChannels;\n\tlet output = audioCtx.createBuffer(\n\t\tchannels,\n\t\tbuffers.map(buffer => buffer.length).reduce((a, b) => a + b, 0),\n\t\tbuffers[0].sampleRate,\n\t)\n\n\tfor (let channel = 0; channel < channels; channel++) {\n\t\tlet offset = 0;\n\t\tbuffers.map(buffer => {\n\t\t\toutput.getChannelData(channel).set(buffer.getChannelData(channel), offset);\n\t\t\toffset += buffer.length;\n\t\t});\n\t}\n\treturn output;\n}\n\nexport const layerAudioBuffers = (audioCtx: AudioContext, buffers: AudioBuffer[]): AudioBuffer => {\n\tconst channels = buffers[0].numberOfChannels;\n\tlet output = audioCtx.createBuffer(\n\t\tchannels,\n\t\tbuffers.map(buffer => buffer.length).reduce((a, b) => a + b, 0),\n\t\tbuffers[0].sampleRate,\n\t);\n\n\tfor (let channel = 0; channel < channels; channel++) {\n\t\tbuffers.map(buffer => {\n\t\t\tfor (let i = buffer.getChannelData(channel).length - 1; i >= 0; i--) {\n\t\t\t\toutput.getChannelData(channel)[i] += buffer.getChannelData(channel)[i];\n\t\t\t}\n\t\t});\n\t}\n\treturn output;\n}\n"]}