{"version":3,"sources":["timeline.js"],"names":["TimelinePlugin","create","params","name","deferInit","instance","constructor","ws","wrapper","drawer","scrollLeft","render","wavesurfer","pixelRatio","maxCanvasWidth","width","maxCanvasElementWidth","Math","round","addEventListener","_onScroll","on","_onRedraw","_onZoom","e","preventDefault","relX","offsetX","layerX","fireEvent","scrollWidth","container","document","querySelector","Error","util","Object","assign","height","notchPercentHeight","labelPadding","unlabeledNotchColor","primaryColor","secondaryColor","primaryFontColor","secondaryFontColor","fontFamily","fontSize","duration","zoomDebounce","formatTimeCallback","defaultFormatTimeCallback","timeInterval","defaultTimeInterval","primaryLabelInterval","defaultPrimaryLabelInterval","secondaryLabelInterval","defaultSecondaryLabelInterval","offset","canvases","debounce","init","isReady","_onReady","once","destroy","unAll","un","removeEventListener","parentNode","_onWrapperClick","removeChild","createWrapper","wsParams","innerHTML","appendChild","createElement","style","display","position","userSelect","webkitUserSelect","paddingBottom","fillParent","scrollParent","overflowX","overflowY","updateCanvases","updateCanvasesPositioning","renderCanvases","addCanvas","newCanvas","borderRadius","canvas","push","zIndex","removeCanvas","pop","parentElement","totalWidth","requiredCanvases","ceil","length","canvasesLength","forEach","i","canvasWidth","left","backend","getDuration","totalSeconds","parseInt","getWidth","height1","height2","pixelsPerSecond","formatTime","intervalFnOrVal","option","curPixel","curSeconds","positioning","renderPositions","cb","pos","setFillStyles","setFonts","fillRect","fillText","fillStyle","getContext","font","x","y","leftOffset","intersection","x1","max","y1","x2","min","y2","text","textWidth","xOffset","context","measureText","seconds","pxPerSec","minutes"],"mappings":"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","sourcesContent":["/**\n * @typedef {Object} TimelinePluginParams\n * @desc Extends the `WavesurferParams` wavesurfer was initialised with\n * @property {!string|HTMLElement} container CSS selector or HTML element where\n * the timeline should be drawn. This is the only required parameter.\n * @property {number} notchPercentHeight=90 Height of notches in percent\n * @property {string} unlabeledNotchColor='#c0c0c0' The colour of the notches\n * that do not have labels\n * @property {string} primaryColor='#000' The colour of the main notches\n * @property {string} secondaryColor='#c0c0c0' The colour of the secondary\n * notches\n * @property {string} primaryFontColor='#000' The colour of the labels next to\n * the main notches\n * @property {string} secondaryFontColor='#000' The colour of the labels next to\n * the secondary notches\n * @property {number} labelPadding=5 The padding between the label and the notch\n * @property {?number} zoomDebounce A debounce timeout to increase rendering\n * performance for large files\n * @property {string} fontFamily='Arial'\n * @property {number} fontSize=10 Font size of labels in pixels\n * @property {?number} duration Length of the track in seconds. Overrides\n * getDuration() for setting length of timeline\n * @property {function} formatTimeCallback (sec, pxPerSec) -> label\n * @property {function} timeInterval (pxPerSec) -> seconds between notches\n * @property {function} primaryLabelInterval (pxPerSec) -> cadence between\n * labels in primary color\n * @property {function} secondaryLabelInterval (pxPerSec) -> cadence between\n * labels in secondary color\n * @property {?number} offset Offset for the timeline start in seconds. May also be\n * negative.\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('timeline')`\n */\n\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wavesurfer.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wavesurfer.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nexport default class TimelinePlugin {\n  /**\n   * Timeline plugin definition factory\n   *\n   * This function must be used to create a plugin definition which can be\n   * used by wavesurfer to correctly instantiate the plugin.\n   *\n   * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n   * @return {PluginDefinition} an object representing the plugin\n   */\n  static create(params) {\n    return {\n      name: 'timeline',\n      deferInit: params && params.deferInit ? params.deferInit : false,\n      params: params,\n      instance: TimelinePlugin,\n    };\n  }\n\n  // event handlers\n  _onScroll = () => {\n    if (this.wrapper && this.drawer.wrapper) {\n      this.wrapper.scrollLeft = this.drawer.wrapper.scrollLeft;\n    }\n  };\n\n  /**\n   * @returns {void}\n   */\n  _onRedraw = () => this.render();\n\n  _onReady = () => {\n    const ws = this.wavesurfer;\n    this.drawer = ws.drawer;\n    this.pixelRatio = ws.drawer.params.pixelRatio;\n    this.maxCanvasWidth = ws.drawer.maxCanvasWidth || ws.drawer.width;\n    this.maxCanvasElementWidth =\n      ws.drawer.maxCanvasElementWidth ||\n      Math.round(this.maxCanvasWidth / this.pixelRatio);\n\n    // add listeners\n    ws.drawer.wrapper.addEventListener('scroll', this._onScroll);\n    ws.on('redraw', this._onRedraw);\n    ws.on('zoom', this._onZoom);\n\n    this.render();\n  };\n\n  /**\n   * @param {object} e Click event\n   */\n  _onWrapperClick = (e) => {\n    e.preventDefault();\n    const relX = 'offsetX' in e ? e.offsetX : e.layerX;\n    this.fireEvent('click', relX / this.wrapper.scrollWidth || 0);\n  };\n\n  /**\n   * Creates an instance of TimelinePlugin.\n   *\n   * You probably want to use TimelinePlugin.create()\n   *\n   * @param {TimelinePluginParams} params Plugin parameters\n   * @param {object} ws Wavesurfer instance\n   */\n  constructor(params, ws) {\n    this.container =\n      'string' == typeof params.container\n        ? document.querySelector(params.container)\n        : params.container;\n\n    if (!this.container) {\n      throw new Error('No container for wavesurfer timeline');\n    }\n\n    this.wavesurfer = ws;\n    this.util = ws.util;\n    this.params = Object.assign(\n      {},\n      {\n        height: 20,\n        notchPercentHeight: 90,\n        labelPadding: 5,\n        unlabeledNotchColor: '#c0c0c0',\n        primaryColor: '#000',\n        secondaryColor: '#c0c0c0',\n        primaryFontColor: '#000',\n        secondaryFontColor: '#000',\n        fontFamily: 'Arial',\n        fontSize: 10,\n        duration: null,\n        zoomDebounce: false,\n        formatTimeCallback: this.defaultFormatTimeCallback,\n        timeInterval: this.defaultTimeInterval,\n        primaryLabelInterval: this.defaultPrimaryLabelInterval,\n        secondaryLabelInterval: this.defaultSecondaryLabelInterval,\n        offset: 0,\n      },\n      params,\n    );\n\n    this.canvases = [];\n    this.wrapper = null;\n    this.drawer = null;\n    this.pixelRatio = null;\n    this.maxCanvasWidth = null;\n    this.maxCanvasElementWidth = null;\n    /**\n     * This event handler has to be in the constructor function because it\n     * relies on the debounce function which is only available after\n     * instantiation\n     *\n     * Use a debounced function if `params.zoomDebounce` is defined\n     *\n     * @returns {void}\n     */\n    this._onZoom = this.params.zoomDebounce\n      ? this.wavesurfer.util.debounce(\n          () => this.render(),\n          this.params.zoomDebounce,\n        )\n      : () => this.render();\n  }\n\n  /**\n   * Initialisation function used by the plugin API\n   */\n  init() {\n    // Check if ws is ready\n    if (this.wavesurfer.isReady) {\n      this._onReady();\n    } else {\n      this.wavesurfer.once('ready', this._onReady);\n    }\n  }\n\n  /**\n   * Destroy function used by the plugin API\n   */\n  destroy() {\n    this.unAll();\n    this.wavesurfer.un('redraw', this._onRedraw);\n    this.wavesurfer.un('zoom', this._onZoom);\n    this.wavesurfer.un('ready', this._onReady);\n    this.wavesurfer.drawer.wrapper.removeEventListener(\n      'scroll',\n      this._onScroll,\n    );\n    if (this.wrapper && this.wrapper.parentNode) {\n      this.wrapper.removeEventListener('click', this._onWrapperClick);\n      this.wrapper.parentNode.removeChild(this.wrapper);\n      this.wrapper = null;\n    }\n  }\n\n  /**\n   * Create a timeline element to wrap the canvases drawn by this plugin\n   *\n   */\n  createWrapper() {\n    const wsParams = this.wavesurfer.params;\n    this.container.innerHTML = '';\n    this.wrapper = this.container.appendChild(\n      document.createElement('timeline'),\n    );\n    this.util.style(this.wrapper, {\n      display: 'block',\n      position: 'relative',\n      userSelect: 'none',\n      webkitUserSelect: 'none',\n      height: `${this.params.height}px`,\n      paddingBottom: '10px',\n    });\n\n    if (wsParams.fillParent || wsParams.scrollParent) {\n      this.util.style(this.wrapper, {\n        width: '100%',\n        overflowX: 'hidden',\n        overflowY: 'hidden',\n      });\n    }\n\n    this.wrapper.addEventListener('click', this._onWrapperClick);\n  }\n\n  /**\n   * Render the timeline (also updates the already rendered timeline)\n   *\n   */\n  render() {\n    if (!this.wrapper) {\n      this.createWrapper();\n    }\n    this.updateCanvases();\n    this.updateCanvasesPositioning();\n    this.renderCanvases();\n  }\n\n  /**\n   * Add new timeline canvas\n   *\n   */\n  addCanvas() {\n    const newCanvas = document.createElement('canvas');\n    newCanvas.style.borderRadius = 'inherit';\n    const canvas = this.wrapper.appendChild(newCanvas);\n    this.canvases.push(canvas);\n    this.util.style(canvas, {\n      position: 'absolute',\n      zIndex: 4,\n    });\n  }\n\n  /**\n   * Remove timeline canvas\n   *\n   */\n  removeCanvas() {\n    const canvas = this.canvases.pop();\n    canvas.parentElement.removeChild(canvas);\n  }\n\n  /**\n   * Make sure the correct of timeline canvas elements exist and are cached in\n   * this.canvases\n   *\n   */\n  updateCanvases() {\n    const totalWidth = Math.round(this.drawer.wrapper.scrollWidth);\n    const requiredCanvases = Math.ceil(totalWidth / this.maxCanvasElementWidth);\n\n    while (this.canvases.length < requiredCanvases) {\n      this.addCanvas();\n    }\n\n    while (this.canvases.length > requiredCanvases) {\n      this.removeCanvas();\n    }\n  }\n\n  /**\n   * Update the dimensions and positioning style for all the timeline canvases\n   *\n   */\n  updateCanvasesPositioning() {\n    // cache length for performance\n    const canvasesLength = this.canvases.length;\n    this.canvases.forEach((canvas, i) => {\n      // canvas width is the max element width, or if it is the last the\n      // required width\n      const canvasWidth =\n        i === canvasesLength - 1\n          ? this.drawer.wrapper.scrollWidth -\n            this.maxCanvasElementWidth * (canvasesLength - 1)\n          : this.maxCanvasElementWidth;\n      // set dimensions and style\n      canvas.width = canvasWidth * this.pixelRatio;\n      // on certain pixel ratios the canvas appears cut off at the bottom,\n      // therefore leave 1px extra\n      canvas.height = (this.params.height + 1) * this.pixelRatio;\n      this.util.style(canvas, {\n        width: `${canvasWidth}px`,\n        height: `${this.params.height}px`,\n        left: `${i * this.maxCanvasElementWidth}px`,\n      });\n    });\n  }\n\n  /**\n   * Render the timeline labels and notches\n   *\n   */\n  renderCanvases() {\n    const duration =\n      this.params.duration || this.wavesurfer.backend.getDuration();\n\n    if (duration <= 0) {\n      return;\n    }\n    const wsParams = this.wavesurfer.params;\n    const fontSize = this.params.fontSize * wsParams.pixelRatio;\n    const totalSeconds = parseInt(duration, 10) + 1;\n    const width =\n      wsParams.fillParent && !wsParams.scrollParent\n        ? this.drawer.getWidth()\n        : this.drawer.wrapper.scrollWidth * wsParams.pixelRatio;\n    const height1 = this.params.height * this.pixelRatio;\n    const height2 =\n      this.params.height *\n      (this.params.notchPercentHeight / 100) *\n      this.pixelRatio;\n    const pixelsPerSecond = width / duration;\n\n    const formatTime = this.params.formatTimeCallback;\n    // if parameter is function, call the function with\n    // pixelsPerSecond, otherwise simply take the value as-is\n    const intervalFnOrVal = (option) =>\n      typeof option === 'function' ? option(pixelsPerSecond) : option;\n    const timeInterval = intervalFnOrVal(this.params.timeInterval);\n    const primaryLabelInterval = intervalFnOrVal(\n      this.params.primaryLabelInterval,\n    );\n    const secondaryLabelInterval = intervalFnOrVal(\n      this.params.secondaryLabelInterval,\n    );\n\n    let curPixel = pixelsPerSecond * this.params.offset;\n    let curSeconds = 0;\n    let i;\n    // build an array of position data with index, second and pixel data,\n    // this is then used multiple times below\n    const positioning = [];\n    for (i = 0; i < totalSeconds / timeInterval; i++) {\n      positioning.push([i, curSeconds, curPixel]);\n      curSeconds += timeInterval;\n      curPixel += pixelsPerSecond * timeInterval;\n    }\n\n    // iterate over each position\n    const renderPositions = (cb) => {\n      positioning.forEach((pos) => {\n        cb(pos[0], pos[1], pos[2]);\n      });\n    };\n\n    // render primary labels\n    this.setFillStyles(this.params.primaryColor);\n    this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n    this.setFillStyles(this.params.primaryFontColor);\n    renderPositions((i, curSeconds, curPixel) => {\n      if (i % primaryLabelInterval === 0) {\n        this.fillRect(curPixel, this.params.height + height2, 1, height2);\n        this.fillText(\n          formatTime(curSeconds, pixelsPerSecond),\n          curPixel + this.params.labelPadding * this.pixelRatio,\n          height1 - height2,\n        );\n      }\n    });\n\n    // render secondary labels\n    this.setFillStyles(this.params.secondaryColor);\n    this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n    this.setFillStyles(this.params.secondaryFontColor);\n    renderPositions((i, curSeconds, curPixel) => {\n      if (i % secondaryLabelInterval === 0) {\n        this.fillRect(curPixel, this.params.height + height2, 1, height2);\n        this.fillText(\n          formatTime(curSeconds, pixelsPerSecond),\n          curPixel + this.params.labelPadding * this.pixelRatio,\n          height1 - height2,\n        );\n      }\n    });\n\n    // render the actual notches (when no labels are used)\n    this.setFillStyles(this.params.unlabeledNotchColor);\n    renderPositions((i, curSeconds, curPixel) => {\n      if (i % secondaryLabelInterval !== 0 && i % primaryLabelInterval !== 0) {\n        this.fillRect(\n          curPixel,\n          this.params.height + height2 * 1.5,\n          1,\n          height2 * 0.5,\n        );\n      }\n    });\n  }\n\n  /**\n   * Set the canvas fill style\n   *\n   * @param {DOMString|CanvasGradient|CanvasPattern} fillStyle Fill style to\n   * use\n   */\n  setFillStyles(fillStyle) {\n    this.canvases.forEach((canvas) => {\n      canvas.getContext('2d').fillStyle = fillStyle;\n    });\n  }\n\n  /**\n   * Set the canvas font\n   *\n   * @param {DOMString} font Font to use\n   */\n  setFonts(font) {\n    this.canvases.forEach((canvas) => {\n      canvas.getContext('2d').font = font;\n    });\n  }\n\n  /**\n   * Draw a rectangle on the canvases\n   *\n   * (it figures out the offset for each canvas)\n   *\n   * @param {number} x X-position\n   * @param {number} y Y-position\n   * @param {number} width Width\n   * @param {number} height Height\n   */\n  fillRect(x, y, width, height) {\n    this.canvases.forEach((canvas, i) => {\n      const leftOffset = i * this.maxCanvasWidth;\n\n      const intersection = {\n        x1: Math.max(x, i * this.maxCanvasWidth),\n        y1: y,\n        x2: Math.min(x + width, i * this.maxCanvasWidth + canvas.width),\n        y2: y + height,\n      };\n\n      if (intersection.x1 < intersection.x2) {\n        canvas\n          .getContext('2d')\n          .fillRect(\n            intersection.x1 - leftOffset,\n            intersection.y1,\n            intersection.x2 - intersection.x1,\n            intersection.y2 - intersection.y1,\n          );\n      }\n    });\n  }\n\n  /**\n   * Fill a given text on the canvases\n   *\n   * @param {string} text Text to render\n   * @param {number} x X-position\n   * @param {number} y Y-position\n   */\n  fillText(text, x, y) {\n    let textWidth;\n    let xOffset = 0;\n\n    this.canvases.forEach((canvas) => {\n      const context = canvas.getContext('2d');\n      const canvasWidth = context.canvas.width;\n\n      if (xOffset > x + textWidth) {\n        return;\n      }\n\n      if (xOffset + canvasWidth > x) {\n        textWidth = context.measureText(text).width;\n        context.fillText(text, x - xOffset, y);\n      }\n\n      xOffset += canvasWidth;\n    });\n  }\n\n  /**\n   * Turn the time into a suitable label for the time.\n   *\n   * @param {number} seconds Seconds to format\n   * @param {number} pxPerSec Pixels per second\n   * @returns {number} Time\n   */\n  defaultFormatTimeCallback(seconds, pxPerSec) {\n    if (seconds / 60 > 1) {\n      // calculate minutes and seconds from seconds count\n      const minutes = parseInt(seconds / 60, 10);\n      seconds = parseInt(seconds % 60, 10);\n      // fill up seconds with zeroes\n      seconds = seconds < 10 ? '0' + seconds : seconds;\n      return `${minutes}:${seconds}`;\n    }\n    return Math.round(seconds * 1000) / 1000;\n  }\n\n  /**\n   * Return how many seconds should be between each notch\n   *\n   * @param {number} pxPerSec Pixels per second\n   * @returns {number} Time\n   */\n  defaultTimeInterval(pxPerSec) {\n    if (pxPerSec >= 25) {\n      return 1;\n    } else if (pxPerSec * 5 >= 25) {\n      return 5;\n    } else if (pxPerSec * 15 >= 25) {\n      return 15;\n    }\n    return Math.ceil(0.5 / pxPerSec) * 60;\n  }\n\n  /**\n   * Return the cadence of notches that get labels in the primary color.\n   *\n   * @param {number} pxPerSec Pixels per second\n   * @returns {number} Cadence\n   */\n  defaultPrimaryLabelInterval(pxPerSec) {\n    if (pxPerSec >= 25) {\n      return 10;\n    } else if (pxPerSec * 5 >= 25) {\n      return 6;\n    } else if (pxPerSec * 15 >= 25) {\n      return 4;\n    }\n    return 4;\n  }\n\n  /**\n   * Return the cadence of notches that get labels in the secondary color.\n   *\n   * @param {number} pxPerSec Pixels per second\n   * @returns {number} Cadence\n   */\n  defaultSecondaryLabelInterval(pxPerSec) {\n    if (pxPerSec >= 25) {\n      return 5;\n    } else if (pxPerSec * 5 >= 25) {\n      return 2;\n    } else if (pxPerSec * 15 >= 25) {\n      return 2;\n    }\n    return 2;\n  }\n}\n"]}